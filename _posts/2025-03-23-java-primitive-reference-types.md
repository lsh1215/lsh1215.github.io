---
title: "자바 원시 타입과 참조 타입 [CS 면접 박살내기]"
date: 2025-03-23 10:00:00 +0900
categories: [CS 면접 박살내기]
tags: [Java, Primitive Types, Reference Types, 메모리, Stack, Heap, 면접준비]
---

# 자바 원시 타입과 참조 타입 🎯

자바를 처음 배울 때 가장 헷갈렸던 부분이 바로 원시 타입과 참조 타입의 차이점이었다. `int`와 `Integer`의 차이, `String`이 왜 참조 타입인지, 메모리에서는 어떻게 저장되는지... 이번에는 자바의 데이터 타입에 대해 차근차근 알아보자.

## 자바의 데이터 타입 분류 📊

자바에서는 크게 두 가지 데이터 타입이 있다:

1. **원시 타입(Primitive Data Types)** ⚡ - 8가지 기본 타입
2. **참조 타입(Reference Data Types)** 🔗 - 객체를 참조하는 타입

이 둘의 가장 큰 차이점은 **메모리에 값을 어떻게 저장하느냐**에 있다.

## 원시 타입(Primitive Data Types) ⚡

원시 타입은 자바에서 가장 기본적이며 내장된 데이터 타입이다. 

**값 자체를 메모리에 직접 저장**하는 방식으로, 객체가 아닌 실제 데이터를 다룬다.

### 원시 타입의 특징

```java
int x = 10;
```

이렇게 선언하면 변수 `x`는 스택 메모리의 특정 주소에 저장되고, 그 주소에는 **값 10이 직접 저장**된다.

- **값을 직접 저장**: 객체처럼 참조 주소를 저장하는 것이 아님
- **성능이 빠름**: 메모리 접근이 직접적
- **메모리 효율적**: 추가 오버헤드 없음
- **null 불가능**: 항상 실제 값을 가져야 함

### 자바의 8가지 원시 타입

| 분류 | 타입 | 크기 | 값 범위 또는 특징 |
|------|------|------|-------------------|
| **정수형** | `byte` | 1 byte | -128 ~ 127 |
| | `short` | 2 bytes | -32,768 ~ 32,767 |
| | `int` | 4 bytes | -2³¹ ~ 2³¹-1 (기본 정수형) |
| | `long` | 8 bytes | -2⁶³ ~ 2⁶³-1 |
| **실수형** | `float` | 4 bytes | 소수점 지원, 단정도 |
| | `double` | 8 bytes | 기본 실수형, 배정도 |
| **문자형** | `char` | 2 bytes | 유니코드 문자 한 글자 |
| **논리형** | `boolean` | 1 bit | `true` 또는 `false` |

### 원시 타입 사용 예시

```java
// 정수형
int age = 25;
long population = 1000000000L;

// 실수형
double price = 19.99;
float rate = 3.14f;

// 문자형
char grade = 'A';

// 논리형
boolean isActive = true;
```

## 참조 타입(Reference Data Types) 🔗

참조 타입은 실제 데이터를 직접 저장하지 않고, **힙 메모리에 있는 객체의 주소(참조값)**를 저장하는 데이터 타입이다.

### 참조 타입의 특징

```java
String str = "Hello";
```

이렇게 선언하면:

- `str`은 **스택 메모리**에 저장됨
- `"Hello"`라는 실제 값은 **힙 메모리**에 저장됨
- `str`은 그 값을 가리키는 **주소(참조값)**만 저장함

즉, `str`은 값 자체가 아닌 **값이 위치한 주소**를 저장한다.

### 참조 타입의 종류

| 참조 타입 | 설명 | 예시 |
|-----------|------|------|
| `String` | 문자열 객체 | `String name = "김철수";` |
| `Array` | 배열 (모든 타입의 배열은 객체) | `int[] numbers = {1, 2, 3};` |
| `Interface` | 인터페이스 타입 변수 | `List<String> list;` |
| `Enum` | 열거형 | `Color.RED` |
| `Class` | 우리가 만든 모든 클래스 | `User user = new User();` |

### 참조 타입 사용 예시

```java
// String
String name = "김철수";
String nullString = null; // null 가능

// Array
int[] numbers = {1, 2, 3, 4, 5};
String[] fruits = {"사과", "바나나", "오렌지"};

// Class
User user = new User("김철수", 25);
List<String> list = new ArrayList<>();
```

## 원시 타입 vs 참조 타입 비교 ⚖️

| 항목 | 원시 타입 | 참조 타입 |
|------|-----------|-----------|
| **저장 방식** | 스택에 값 직접 저장 | 스택에 주소, 값은 힙 |
| **예시** | `int x = 10;` | `String s = "Hi";` |
| **성능** | 빠름 ⚡ | 상대적으로 느림 🐌 |
| **메모리 사용량** | 적음 💪 | 많음 (객체 오버헤드) 📦 |
| **null 가능성** | 불가능 ❌ | 가능 ✅ |
| **기본값** | 타입별 기본값 존재 | `null` |

## 메모리 관점에서의 차이점

### 원시 타입의 메모리 저장

```
스택 메모리:
┌─────────┬─────────┐
│ 변수명  │ 값      │
├─────────┼─────────┤
│ x       │ 10      │  ← 값이 직접 저장됨
└─────────┴─────────┘
```

### 참조 타입의 메모리 저장

```
스택 메모리:          힙 메모리:
┌─────────┬─────────┐  ┌─────────┬─────────┐
│ 변수명  │ 주소    │  │ 주소    │ 값      │
├─────────┼─────────┤  ├─────────┼─────────┤
│ str     │ 0x1234  │→ │ 0x1234  │ "Hello" │
└─────────┴─────────┘  └─────────┴─────────┘
```

## Wrapper 클래스와의 관계

원시 타입에는 각각 대응하는 Wrapper 클래스가 있다:

| 원시 타입 | Wrapper 클래스 |
|-----------|----------------|
| `byte` | `Byte` |
| `short` | `Short` |
| `int` | `Integer` |
| `long` | `Long` |
| `float` | `Float` |
| `double` | `Double` |
| `char` | `Character` |
| `boolean` | `Boolean` |

### Auto-boxing과 Auto-unboxing

```java
// Auto-boxing: 원시 타입 → Wrapper 클래스
Integer num = 10; // int 10이 Integer 객체로 자동 변환

// Auto-unboxing: Wrapper 클래스 → 원시 타입
int value = num; // Integer 객체가 int로 자동 변환
```

## 실제 사용 시 주의사항 ⚠️

### 1. null 처리

```java
// 원시 타입 - null 불가능
int age = null; // 컴파일 에러!

// 참조 타입 - null 가능
String name = null; // 가능
if (name != null) {
    System.out.println(name.length());
}
```

### 2. 비교 연산

```java
// 원시 타입 - 값 비교
int a = 10;
int b = 10;
System.out.println(a == b); // true

// 참조 타입 - 주소 비교 (주의!)
String str1 = new String("Hello");
String str2 = new String("Hello");
System.out.println(str1 == str2); // false! (주소가 다름)
System.out.println(str1.equals(str2)); // true (값 비교)
```

### 3. 메모리 효율성

```java
// 원시 타입 - 메모리 효율적
int[] numbers = new int[1000]; // 4KB

// 참조 타입 - 메모리 오버헤드
Integer[] numbers = new Integer[1000]; // 4KB + 객체 오버헤드
```

## 면접용 핵심 정리 🎯

### 원시 타입
> "자바의 원시 타입은 객체가 아닌 실제 값을 메모리에 직접 저장하는 타입으로, 총 8가지가 존재하며 빠르고 효율적인 데이터 처리를 가능하게 한다."

### 참조 타입
> "참조 타입은 값이 아닌 객체의 주소를 저장하며, 해당 주소를 통해 힙 메모리에 있는 실제 데이터를 간접적으로 참조하는 방식이다."

### 차이점 요약
> "원시 타입은 스택에 값을 직접 저장하고 null이 불가능하며 성능이 빠르고, 참조 타입은 스택에 주소를 저장하고 힙에 값을 저장하며 null이 가능하고 상대적으로 느리다."

## 결론 🎉

자바에서 원시 타입과 참조 타입을 구분하는 것은 메모리 관리와 성능 최적화에 매우 중요하다. 

- **간단한 데이터**나 **성능이 중요한 경우**에는 원시 타입을 사용하고
- **복잡한 객체**나 **null 처리가 필요한 경우**에는 참조 타입을 사용하는 것이 좋다

이런 기본 개념을 정확히 이해하고 있다면, 면접에서도 자신 있게 답변할 수 있을 것이다!
